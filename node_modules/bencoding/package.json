{
  "name": "bencoding",
  "version": "0.0.1",
  "description": "encode/decode bencoded data",
  "keywords": [
    "torrent",
    "bittorrent",
    "bencode",
    "bdecode",
    "bencoding",
    "buffers"
  ],
  "author": {
    "name": "Clark Fischer",
    "email": "clark.fischer@gmail.com",
    "url": "https://github.com/clarkf"
  },
  "main": "index",
  "repository": {
    "type": "git",
    "url": "git://github.com/clarkf/node-bencoding.git"
  },
  "homepage": "https://github.com/clarkf/node-bencoding",
  "scripts": {
    "test": "make test"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "",
    "expect.js": "",
    "benchmark": "~0.3.0",
    "dht-bencode": "",
    "bncode": "",
    "bencode": ""
  },
  "engines": {
    "node": ">= 0.4.7"
  },
  "readme": "# bencoding\n\nA node library for encoding and decoding data, according to [the\nBitTorrent specification](http://www.bittorrent.org/beps/bep_0003.html).\nThis library is slightly different, because it attempts to keep your\ndata as pristine as possible. Nothing (with the exception of integers)\nis converted to a string until you tell it to.\n\n## Why?\n\nThere are a bunch of bencoding/decoding libraries out there (see below),\nbut none of pass their results straight into plain javascript `Object`s\n(`{}`). When using a `Buffer` as a key in an `Object`, it automatically\ngets coerced into a `String`. If you have to use some complex data as a\nkey in a dictionary, it'll munge it when converting it to a `String`.\n\nTake for example a `scrape` request to a HTTP tracker. According to the\n[unofficial BT spec](http://wiki.theory.org/BitTorrentSpecification#Tracker_.27scrape.27_Convention),\nits result is in this format (written in JS-pseudocode for clarity):\n\n```javascript\n{\n    \"files\": {\n        \"[info hash]\": {\n            \"complete\":   5,\n            \"downloaded\": 50,\n            \"incomplete\": 10\n        }\n    }\n}\n```\n\nWhere `[info hash]` is the 20-byte `sha1` `info_hash`. When you coerce\nthis into a string, you get some wonky effects, such as the (20-byte)\n`String`'s `length` being 1. This is not all so helpful, unless you're\ncompletely willing disregard the `info_hash`.\n\n## How can we fix this?\n\n`bencoding` fixes this by creating a new structure: `BDict`. A `BDict`\nrepresents a bencoded dictionary without coercing any `Buffer`s into\n`String`s. It stores everything by index, so you have to fetch the keys\nand values numerically (see API).\n\n## Installation\n\nWith [npm](http://github.com/isaacs/npm):\n\n    npm install bencoding\n\n## Performance\n\nPerformance compared to:\n\n* Mark Schmale's [bencode](https://github.com/themasch/node-bencode/)\n* Tim Becker's [bncode](https://github.com/a2800276/bencode.js/)\n* Stefan Bühler's [dht-bencode](https://github.com/stbuehler/nodejs-dht-bencode)\n\nThis library seems to __decode__ faster than any of the other tested\nlibraries. It __encodes__ quickly – second only to Mark Schmale's \nlibrary. Results:\n\n> Encoding:\n>\n> * bencoding#encode x 24,961 ops/sec ±4.12% (57 runs sampled)\n> * bencode#encode x 2,637,008 ops/sec ±5.86% (58 runs sampled)\n> * bncode#encode x 15,012 ops/sec ±7.66% (46 runs sampled)\n> * dht-bencode#encode x 193,631 ops/sec ±10.35% (53 runs sampled)\n> * Fastest is bencode#encode \n> \n> Decoding:\n>\n> * bencoding#decode x 29,019 ops/sec ±4.41% (55 runs sampled)\n> * bencode#decode x 300 ops/sec ±6.28% (54 runs sampled)\n> * bncode#decode x 1,060 ops/sec ±7.65% (50 runs sampled)\n> * [dht-decode errors]\n> * Fastest is bencoding#decode\n\nYou can try this yourself by running either `node\nperformance/encoding.js` or `node performance/decoding.js`.\n\n## Usage\n\n### Decoding\n```javascript\nvar bencoding = require('bencoding'),\n    data = new Buffer('d3:inti1024768e3:str5:abcde4:listli1ei2ei3eee'),\n    result = bencoding.decode(data);\n\nconsole.log(result);\nconsole.log(result.toJSON());\n```\nOutput:\n\n```\n{ keys: [ <Buffer 69 6e 74>, <Buffer 73 74 72>, <Buffer 6c 69 73 74> ],\n    vals: [ 1024768, <Buffer 61 62 63 64 65>, [ 1, 2, 3 ] ],\n    length: 3 }\n{ int: 1024768, str: <Buffer 61 62 63 64 65>, list: [ 1, 2, 3 ] }\n```\n\n### Encoding\n```javascript\nvar bencoding = require('bencoding'),\n    object = {\n        'string': \"Hello World\",\n        'integer': 12345,\n        'dictionary': {\n            'key': \"This is a string within a dictionary\"\n        },\n        'list': [1, 2, 3, 4, 'string', 5, {}]\n    },\n    result = bencoding.encode(object);\n\nconsole.log(result.toString());\n```\nOutput:\n\n    d6:string11:Hello World7:integeri12345e10:dictionaryd3:key36:This is a string within a dictionarye4:listli1ei2ei3ei4e6:stringi5edeee\n\n## API\n\n### bencode.decode\nSignature: \n\n* {`Buffer`} `encoded` - The bencoded data, as a buffer.\n\nReturns {`Buffer`|`BDict`|`Array`|`Number`} `result` - decoded data\n\n### bencode.encode\nSignature:\n\n* {`Buffer`|`BDict`|`Array`|`String`|`Object`|`Number`} `data` - the\n    data to encode.\n\nReturns {`Buffer`} `result` - encoded data. \n\n### bencode.BDict\nThe BDict constructor. Accepts no arguments.\n\n#### BDict.add\nSignature:\n\n* `key` - the key\n* `value` - the value\n\nReturns: {`BDict`} `self` - for chaining\n\nAdds an item to `BDict` at `length`. `key` and `value` can be any object\nof any kind.\n\n#### BDict.remove\nSignature: \n\n* {`Number`} `index` - the index to remove\n\nReturns: {`BDict`} `self` - for chaining\n\nRemoves item at index `index` from `BDict`\n\n#### BDict.vget\nSignature:\n\n* {`Number`} `index` - the index to get the value of\n\nReturns: `value` - the value at index `index`.\n\n#### BDict.kget\nSignature:\n\n* {`Number`} `index` - the index to get the key of\n\nReturns: `value` - the key at index `index`.\n\n#### BDict.get\nSignature:\n\n* {`Number`} `index` - the index to get the key/value of\n\nReturns: {`Array`} `result` - an array in the format of [`key`, `value`]\n\n#### BDict.toJSON\n\nReturns: {`Object`} `result` - a usable representation of the `BDict`.\n\nIf you don't plan on having any complex data in keys, you can just call\ntoJSON to convert the BDict into a regular `Object`.\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2011 Clark Fischer &lt;clark.fischer@gmail.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/clarkf/node-bencoding/issues"
  },
  "_id": "bencoding@0.0.1",
  "_from": "bencoding@"
}
